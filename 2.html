<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" id="mixia_vpid">
    <title>TVBox的AES-128-CBC加密</title>
    <!-- 仅保留功能依赖库，移除Vue -->
    <script src="./lib/crypto-js.min.js"></script>
    <script src="./lib/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        /* 新增：导航栏与底部样式（来自1.html） */
        .top-nav,.footer-links{background:#4285f4;text-align:center;padding:10px 0;font-size:0}
        .top-nav a,.footer-links a{color:#fff;font-size:13px;margin:0 8px;padding:4px 6px;text-decoration:none}
        .top-nav a:hover,.footer-links a:hover{text-decoration:underline}
        .copyright{background:#f8fafc;font-size:12px;color:#64748b;text-align:center;padding:10px 0;border-top:1px solid #f0f0f0;margin-top:20px}
        /* 原有样式保留 */
        .wrapper { padding: 32px; max-width: 1400px; margin: 0 auto; }
        .wrapper h2 { color: #333; margin-bottom: 24px; font-weight: 600; }
        .inner { display: flex; gap: 24px; }
        .textarea-group { flex: 3; }
        .textarea-group textarea {
            width: 100%;
            min-height: 500px;
            padding: 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            resize: vertical;
            outline: none;
            transition: border-color 0.3s;
        }
        .textarea-group textarea:focus { border-color: #6e8efb; }
        .input-group { flex: 1; display: flex; flex-direction: column; gap: 24px; }
        .input-group select, .input-group input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }
        .input-group select:focus, .input-group input:focus { border-color: #6e8efb; }
        .input-group input:disabled { background-color: #f9fafb; color: #9ca3af; cursor: not-allowed; }
        .btn-group { display: flex; gap: 12px; }
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s;
            text-align: center;
        }
        .btn-primary { background-color: #6e8efb; color: white; }
        .btn-primary:hover { background-color: #5a7de3; }
        .btn-success { background-color: #34d399; color: white; }
        .btn-success:hover { background-color: #22c55e; }
        #fileInput { position: absolute; opacity: 0; width: 0; height: 0; }
        .img-btn { width: 100%; padding: 12px; background-color: #6e8efb; color: white; border: none; border-radius: 8px; cursor: pointer; }
        .img-btn:hover { background-color: #5a7de3; }
        #imgRenderContainer {
            display: none;
            width: 600px;
            padding: 20px;
            background: white;
            word-break: break-all;
            font-size: 14px;
            color: #333;
        }
        .tip-success { color: #22c55e; }
        .tip-error { color: #ef4444; }
        @media (max-width: 768px) {
            .inner { flex-direction: column; }
            .input-group { margin: 20px 0; }
            .btn-group { flex-direction: column; }
            #imgRenderContainer { width: 90%; }
        }
    </style>
</head>
<body>
    <!-- 新增：顶部导航栏（来自1.html） -->
    <div class="top-nav">
        <a href="./index.html">我的主页</a>
        <a href="./1.html">格式转换</a>
        <a href="./2.html">加密工具</a>
        <a href="./pl.html">批量工具</a>
    </div>

    <!-- 原有核心内容保留 -->
    <div class="wrapper">
        <h2>TVBox的AES-128-CBC加密</h2>
        <div class="inner">
            <!-- 左侧输入区：用id绑定原生DOM -->
            <div class="textarea-group">
                <textarea id="inputContent" placeholder="请输入内容，或点击“上传文件”导入"></textarea>
            </div>
            <!-- 中间控制区：用id绑定原生DOM -->
            <div class="input-group">
                <select id="operateType">
                    <option value="encrypt">加密</option>
                    <option value="decrypt">解密</option>
                </select>
                <input id="key" type="text" maxlength="16" placeholder="KEY/密码（最多16位）" value="123456">
                <input id="iv" type="text" disabled="" placeholder="IV/向量（自动生成）">
                <div class="btn-group">
                    <label class="btn btn-primary" for="fileInput">
                        上传文件
                        <input type="file" id="fileInput" accept=".txt,.json,.conf">
                    </label>
                    <button class="btn btn-success" id="doOperateBtn">
                        加密下载 <!-- 默认初始文本 -->
                    </button>
                </div>
                <button class="img-btn" id="convertToImageBtn">
                    配置转图片
                </button>
            </div>
            <!-- 右侧结果区：用id绑定原生DOM -->
            <div class="textarea-group">
                <textarea id="result" placeholder="结果将显示在这里（操作反馈也会显示此处）" readonly=""></textarea>
            </div>
        </div>
    </div>

    <!-- 图片生成容器（原有保留） -->
    <div id="imgRenderContainer">
        <h3 style="margin-bottom: 15px; color: #6e8efb;">TVBox配置结果</h3>
        <p style="margin-bottom: 10px;"><strong>操作类型：</strong><span id="imgOperateType">加密</span></p>
        <p style="margin-bottom: 10px;"><strong>使用密钥：</strong><span id="imgKey">123456</span></p>
        <p style="margin-bottom: 10px;"><strong>使用IV：</strong><span id="imgIv">1680000000000</span></p>
        <p style="margin-bottom: 10px;"><strong>结果内容：</strong></p>
        <div id="imgResultContent" style="padding: 10px; border: 1px solid #eee; border-radius: 4px; background: #f9fafb;"></div>
    </div>

    <!-- 新增：底部链接栏与版权（来自1.html） -->
    <div class="footer-links">
        <a onclick="window.open('https://link3.cc/gyjune')">我的工具箱</a>
        <a onclick="alert('邮箱：gyjune@126.com')">我的邮箱</a>
        <a onclick="window.open('https://weibo.com/u/1771411553')">我的微博</a>
        <a href="./1.html">格式转换</a>
        <a href="./zby.html">直播源生成工具</a>
        <a href="./sc.php">直播源上传工具</a>
    </div>
    <div class="copyright">Copyright © 2025 多功能网站 | 版权所有</div>

    <!-- 原有核心脚本保留 -->
    <script>
        // 1. 核心加密逻辑（完全保留不变）
        function padTo16Byte(str) {
            return CryptoJS.enc.Utf8.parse(str.toString().padEnd(16, '0'));
        }
        function Encrypt(word, keyStr, ivStr) {
            const key = padTo16Byte(keyStr);
            const iv = padTo16Byte(ivStr);
            const encrypted = CryptoJS.AES.encrypt(word, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
            return encrypted.ciphertext.toString(CryptoJS.enc.Hex);
        }
        function decryptAesBCB(encryptedData) {
            try {
                const dataArr = encryptedData.split("");
                const prefixCode = CryptoJS.enc.Utf8.parse("$#").toString();
                const suffixCode = CryptoJS.enc.Utf8.parse("#$").toString();
                const pwdMixEndIndex = encryptedData.indexOf(suffixCode) + suffixCode.length;
                const pwdMix = dataArr.splice(0, pwdMixEndIndex).join("");
                const roundtimeInHax = dataArr.splice(dataArr.length - 26, 26).join("");
                const encryptedText = dataArr.join("");
                const pwdInHax = pwdMix.substring(prefixCode.length, pwdMix.length - suffixCode.length);
                const roundTime = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Hex.parse(roundtimeInHax));
                const pwd = CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Hex.parse(pwdInHax));
                const iv = CryptoJS.enc.Utf8.parse(roundTime.padEnd(16, "0"));
                const pkBlocks = CryptoJS.enc.Utf8.parse(pwd.padEnd(16, "0"));
                const cipherParams = CryptoJS.lib.CipherParams.create({ ciphertext: CryptoJS.enc.Hex.parse(encryptedText) });
                return CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(cipherParams, pkBlocks, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }));
            } catch (err) {
                throw new Error("解密格式错误，请确认是加密后的字符串");
            }
        }
        function convertToHex(value) {
            return CryptoJS.enc.Hex.stringify(CryptoJS.enc.Utf8.parse(value));
        }
        // 2. 原生DOM元素获取（替代Vue的ref）
        const dom = {
            inputContent: document.getElementById('inputContent'),
            key: document.getElementById('key'),
            iv: document.getElementById('iv'),
            result: document.getElementById('result'),
            operateType: document.getElementById('operateType'),
            doOperateBtn: document.getElementById('doOperateBtn'),
            fileInput: document.getElementById('fileInput'),
            convertToImageBtn: document.getElementById('convertToImageBtn'),
            // 图片容器相关DOM
            imgRenderContainer: document.getElementById('imgRenderContainer'),
            imgOperateType: document.getElementById('imgOperateType'),
            imgKey: document.getElementById('imgKey'),
            imgIv: document.getElementById('imgIv'),
            imgResultContent: document.getElementById('imgResultContent')
        };
        // 3. 页面初始化（替代Vue的onMounted）
        function init() {
            // 生成初始IV
            dom.iv.value = new Date().getTime().toString();
            // 初始结果提示
            dom.result.value = "初始化完成：IV已自动生成，可开始操作";
            // 绑定“操作类型切换”事件（动态改按钮文本）
            dom.operateType.addEventListener('change', function() {
                dom.doOperateBtn.textContent = this.value === 'encrypt' ? '加密下载' : '解密';
            });
            // 绑定所有功能事件
            bindEvents();
        }
        // 4. 事件绑定（替代Vue的@click/@change）
        function bindEvents() {
            // 上传文件事件
            dom.fileInput.addEventListener('change', readFile);
            // 加密/解密按钮事件
            dom.doOperateBtn.addEventListener('click', doOperate);
            // 配置转图片事件
            dom.convertToImageBtn.addEventListener('click', convertToImage);
        }
        // 5. 上传文件逻辑（原生实现，逻辑不变）
        function readFile(e) {
            const file = e.target.files[0];
            if (!file) {
                dom.result.value = "[提示] 上传异常：未选择文件";
                return;
            }
            const allowedTypes = ['text/plain', 'application/json', 'text/x-conf'];
            const allowedExts = ['.txt', '.json', '.conf'];
            const fileExt = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();
            
            if (!allowedTypes.includes(file.type) && !allowedExts.includes(fileExt)) {
                dom.result.value = `[错误] 上传失败：仅支持 ${allowedExts.join('、')} 格式文件`;
                return;
            }
            const reader = new FileReader();
            reader.onload = function(res) {
                if (res.target.result) {
                    dom.inputContent.value = res.target.result;
                    dom.result.value = `[成功] 上传完成：文件“${file.name}”（大小：${(file.size/1024).toFixed(2)}KB）`;
                } else {
                    dom.result.value = "[错误] 上传失败：文件内容为空";
                }
            };
            reader.onerror = function(err) {
                dom.result.value = `[错误] 上传错误：${err.target.error.message}`;
            };
            reader.readAsText(file, 'UTF-8');
        }
        // 6. 加密/解密逻辑（原生实现，逻辑不变）
        function doOperate() {
            const inputVal = dom.inputContent.value.trim();
            if (!inputVal) {
                dom.result.value = "[提示] 请先输入内容或上传文件，再执行操作";
                return;
            }
            try {
                const operateType = dom.operateType.value;
                const keyVal = dom.key.value;
                const ivVal = dom.iv.value;
                if (operateType === "encrypt") {
                    // 加密逻辑
                    const encryptedContent = Encrypt(inputVal, keyVal, ivVal);
                    const keyHex = convertToHex(`$#${keyVal}#$`);
                    const ivHex = convertToHex(ivVal);
                    const finalResult = keyHex + encryptedContent + ivHex;
                    // 下载JSON文件
                    const blob = new Blob([finalResult], { type: "application/json; charset=utf-8" });
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(blob);
                    a.download = "file.json";
                    a.click();
                    URL.revokeObjectURL(a.href);
                    // 显示结果
                    dom.result.value = `[成功] 加密完成，文件（file.json）已开始下载\n\n加密结果：\n${finalResult}`;
                } else {
                    // 解密逻辑
                    const decryptedContent = decryptAesBCB(inputVal);
                    dom.result.value = `[成功] 解密完成\n\n解密结果：\n${decryptedContent}`;
                }
            } catch (err) {
                dom.result.value = `[错误] 操作失败：${err.message}`;
            }
        }
        // 7. 配置转图片逻辑（原生实现，逻辑不变）
        function convertToImage() {
            const resultVal = dom.result.value.trim();
            if (!resultVal || resultVal.includes("初始化完成") || resultVal.includes("请先")) {
                dom.result.value = "[提示] 请先执行加密/解密操作，生成有效结果后再转图片";
                return;
            }
            // 填充图片容器内容
            const operateType = dom.operateType.value;
            dom.imgOperateType.textContent = operateType === "encrypt" ? "加密" : "解密";
            dom.imgKey.textContent = dom.key.value || "未设置";
            dom.imgIv.textContent = dom.iv.value || "未生成";
            
            // 提取纯结果内容（去掉反馈文本）
            const resultParts = resultVal.split("\n\n");
            const pureResult = resultParts.length > 1 
                ? resultParts[1].replace("加密结果：\n", "").replace("解密结果：\n", "") 
                : resultVal;
            dom.imgResultContent.textContent = pureResult;
            // 显示容器并生成图片
            dom.imgRenderContainer.style.display = "block";
            html2canvas(dom.imgRenderContainer, {
                scale: 2,
                useCORS: true,
                logging: false
            }).then(canvas => {
                // 下载图片
                const imgUrl = canvas.toDataURL("image/png");
                const imgName = `TVBox_${operateType === "encrypt" ? "encrypt" : "decrypt"}.png`;
                const a = document.createElement("a");
                a.href = imgUrl;
                a.download = imgName;
                a.click();
                // 隐藏容器并更新结果提示
                dom.imgRenderContainer.style.display = "none";
                dom.result.value = `[成功] 图片生成完成，文件（${imgName}）已开始下载\n\n原结果：\n${pureResult}`;
            }).catch(err => {
                dom.imgRenderContainer.style.display = "none";
                dom.result.value = `[错误] 转图片失败：${err.message}`;
            });
        }
        // 8. 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
